<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document1</title>
</head>
<body>
<div id="root"></div>
<script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">

  //Class
  class ClassComponent extends React.Component {
    render() {
      return <div> Hellow </div>
    }
  }
  

  //함수
  function FunctionComponent(){
    return <div>Hellow Funcion</div>
  }

  //const를 이용한 화살함수
  const FunciotnComponent2 = () => <div>Hello22</div>

  //사용
  //ReactDOM.render(<FunctionComponent />,document.querySelector('#root'))

  //React.createElement 컴포넌트 만들기
  //React.createElement(
   // type, //HTML 태그 이름 문자열 | 리액트 컴포넌트 | React.Fragment
    //[props],// 리액트 컴포넌트에 넣어주는 데이터 객체
    //[...children] //자식으로 넣어주는 요소들
  //)

  /*
  1. 태그 이름 문자열 type
  ReactDOM.render(
    React.createElement('h1',null,`type 이 "태그 이름 문자열" 입니당.`),
    document.querySelector('#root')
  )
  */

  /*
  2.리액트 컴포넌트 type
  const FunciotnComponentType = () => {
    return React.createElement(
      "p",
      null,
      `type 이 "리액트 컴포넌트" 입니당.`
    )
  }
  ReactDOM.render(
    React.createElement(FunciotnComponentType,null,null),
    document.querySelector('#root')
  )*/

  /*
  3. React.Fragment
  ReactDOM.render(
    React.createElement(
      React.Fragment,
      null,
      `type 이 "리액트 Fragment" 입니당.`
    ),
    document.querySelector('#root')
  )
  ==><div id="root">type 이 "리액트 Fragment" 입니당.</div>
  */
  
  /*
  4. Props or State(개체 형태)
  함수
  function Component(props) {
    return (
      <div><h1>{props.message} 이것은 함수로 만든 컴포넌트.</h1></div>
    )
  }
  

  class Component extends React.Component{
    //state 선언 1방법
    //state = {
     // count:0
   // }
    //state 선언 2방법(생성자)
    constructor(props){
      super(props)
      this.state = {count:0}
    }

    render(){
      return(
        <div>
          <h1>{this.props.message} 이것은 클래스로 만든 컴포넌트</h1>
          <p>{this.state.count}</p>
        </div>
      )
    }

    componentDidMount(){
      setTimeout(()=>{
        //this.setState({//State 변경 할 수 있게 도와주는 함수
          //개체를 한꺼번에 변경 하는 방법
         // count: this.state.count+1
        //})
        //개체의 이전 데이터를 받아서 변경.
        this.setState((previousState) =>{
          const newState = {count: previousState.count +1}
          return newState
        })
      },500)
    }
    // 기본 props 값 지정(클래스에서만)
    static defaultProps={
      message:"기본값~"
    }
  }
  // 기본 props 값 지정(클래스 및 함수에서도 사용가능)
 // Component.defaultProps = {
   // message:"기본값"
  //}
  ReactDOM.render(<Component message="기본값 아니다"/>, document.querySelector('#root'))
  */

  /*
  5. Event Handling
  function Component() {
    return(
      <div>
        <button
          onClick={() =>{
            console.log("Clicked")
          }}
        >
        클릭
        </button>
        </div>
    )
  }
  // 클래스 이벤트
  class Component extends React.Component{
    state = {
      count:0
    }
    constructor(props){
      super(props)
      this.click = this.click.bind(this)//현재 클래스를 click에 바인드
      
    }
    render(){
      return(
        <div>
          <p>{this.state.count}</p>
        <button
          onClick={this.click}
        >
        클릭
        </button>
        </div>
      )
    }
    //setState this 바인딩을 못한다.
    //생성자에서 click메소드를 바인드라는 메소드를 통해서this를 바인드 시키면 아래 처럼 사용 가능.
    //click(){
     // this.setState((state) =>({...state,count:state.count+1})) 
    //}
    //아래 처럼 하면 바인딩 됨
    click = () =>{
      this.setState((state) =>({...state,count:state.count+1}))
    }
  }
  */
 
  
  //라이프 사이클
  let i =0
  class App extends React.Component{
    state = {
      age:30,
      list: []
    }
    interval = null;
    constructor(props){
      super(props)
      console.log("constructor",props)
    }
    render(){
      console.log("Render")
      return(
        <div id="list" style={{height:100, overflow:"scroll"}}>
          {this.state.list.map(i=>{
            return <div>{i}</div>
          })}
          
        </div>
      )
    }
    // Componet 생성 맻 마운트 예제
    //componentWillMount(){
     // console.log('componentWillMount')
   // }
    //렌더가 실행되기 전에 매번 호출.
    static getDerivedStateFromProps(newxProps,prevState){
      console.log('getDerivedStateFromProps',newxProps,prevState)

      //새로운 State 설정 가능.
      //return {
      //  age:390
      // }
      return null
    }
    componentDidMount(){
      setInterval(() =>{
        this.setState((state) =>({
          list: [...state.list,i++]
        }))
      },1000)
    }
    //Component props, state 변경
    //componentWillReceiveProps(nextProps){
    //  console.log('componentWillReceiveProps',nextProps)
   // }
    shouldComponentUpdate(nextProps,nextState){
      console.log('shouldComponentUpdate',nextProps , nextState)
      //반환값이 true: 랜더링되고, false: State,Props가 변경이 되어도 랜더링 되지 않음.
      return true
    }
    //랜더 되기 전.
    //componentWillUpdate(nextProps,nextState){
    //  console.log('componentWillUpdate',nextProps,nextState)
    //}
    //랜더 전 과 랜더 후 를 비교
    getSnapshotBeforeUpdate(prevProps,prevState){
      //리턴값은 Snapshot null Snapshot 저장 하지 않는다.
      if(prevState.list.length === this.state.list.length) return null

      const list = document.querySelector('#list')
      return list.scrollHeight - list.scrollTop
    }

    //랜더 후 
    componentDidUpdate(prevProps,prevState,snapshot){
      console.log('componentWillUpdate',prevProps,prevState,snapshot)
      if(snapshot === null) return 
      const list = document.querySelector('#list')
      list.scrollTop = list.scrollHeight - snapshot
    }

    componentWillUnmount(){
      clearInterval(interval)
    }

    componentDidCatch(error,info){
      console.log('에러시 조치 내용')
    }
  }
  ReactDOM.render(<App name="B"/>,document.querySelector("#root"))

</script>
</body>
</html>